/* tslint:disable */
/* eslint-disable */
/**
 * TASK MVP API
 * AI秘書「TASK」のバックエンドAPI仕様書 (MVP)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddCandidateDatesInput
 */
export interface AddCandidateDatesInput {
    /**
     * 候補日時のISO8601文字列リスト (最低1つ)
     * @type {Array<string>}
     * @memberof AddCandidateDatesInput
     */
    'dates': Array<string>;
}
/**
 * 
 * @export
 * @interface AddEditorInput
 */
export interface AddEditorInput {
    /**
     * 追加する編集者のユーザーID
     * @type {string}
     * @memberof AddEditorInput
     */
    'editorUserId': string;
}
/**
 * 
 * @export
 * @interface AddMemberInput
 */
export interface AddMemberInput {
    /**
     * メンバーの表示名
     * @type {string}
     * @memberof AddMemberInput
     */
    'displayName': string;
    /**
     * LINEユーザーID (ゲストでない場合)
     * @type {string}
     * @memberof AddMemberInput
     */
    'lineUserId'?: string;
    /**
     * ゲストユーザーかどうか (lineUserIdがあればfalse)
     * @type {boolean}
     * @memberof AddMemberInput
     */
    'isGuest'?: boolean;
}
/**
 * 
 * @export
 * @interface AddParticipantInput
 */
export interface AddParticipantInput {
    /**
     * 参加者の表示名
     * @type {string}
     * @memberof AddParticipantInput
     */
    'displayName': string;
    /**
     * LINEユーザーID (ゲストでない場合)
     * @type {string}
     * @memberof AddParticipantInput
     */
    'lineUserId'?: string;
}
/**
 * 
 * @export
 * @interface AddPaymentInput
 */
export interface AddPaymentInput {
    /**
     * 支払者のメンバーID (warikanMembersのドキュメントID)
     * @type {string}
     * @memberof AddPaymentInput
     */
    'payerMemberId': string;
    /**
     * 支払い金額 (正の数)
     * @type {number}
     * @memberof AddPaymentInput
     */
    'amount': number;
    /**
     * 支払い内容のメモ (任意)
     * @type {string}
     * @memberof AddPaymentInput
     */
    'description'?: string;
    /**
     * この支払いに関与したメンバーIDのリスト (任意、指定なければ全員？)
     * @type {Array<string>}
     * @memberof AddPaymentInput
     */
    'participants'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AddWarikanPayment201Response
 */
export interface AddWarikanPayment201Response {
    /**
     * Payment ID
     * @type {string}
     * @memberof AddWarikanPayment201Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CreateProjectInput
 */
export interface CreateProjectInput {
    /**
     * 新しい割り勘プロジェクトの名前
     * @type {string}
     * @memberof CreateProjectInput
     */
    'projectName': string;
}
/**
 * 
 * @export
 * @interface CreateScheduleInput
 */
export interface CreateScheduleInput {
    /**
     * 日程調整のタイトル
     * @type {string}
     * @memberof CreateScheduleInput
     */
    'title': string;
    /**
     * 詳細説明 (任意)
     * @type {string}
     * @memberof CreateScheduleInput
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateSharedMemoInput
 */
export interface CreateSharedMemoInput {
    /**
     * 
     * @type {string}
     * @memberof CreateSharedMemoInput
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSharedMemoInput
     */
    'templateType'?: CreateSharedMemoInputTemplateTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateSharedMemoInput
     */
    'content'?: string;
    /**
     * 関連付けるグループID (任意)
     * @type {string}
     * @memberof CreateSharedMemoInput
     */
    'groupId'?: string;
}

export const CreateSharedMemoInputTemplateTypeEnum = {
    Meeting: 'meeting',
    Outing: 'outing',
    Free: 'free'
} as const;

export type CreateSharedMemoInputTemplateTypeEnum = typeof CreateSharedMemoInputTemplateTypeEnum[keyof typeof CreateSharedMemoInputTemplateTypeEnum];

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * エラーメッセージ
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * エラーメッセージ
     * @type {string}
     * @memberof InlineObject
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ListSharedMemosResponse
 */
export interface ListSharedMemosResponse {
    /**
     * 
     * @type {Array<SharedMemo>}
     * @memberof ListSharedMemosResponse
     */
    'data': Array<SharedMemo>;
    /**
     * 
     * @type {string}
     * @memberof ListSharedMemosResponse
     */
    'nextCursor'?: string;
}
/**
 * 
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * Schedule ID
     * @type {string}
     * @memberof Schedule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'status': ScheduleStatusEnum;
    /**
     * User ID
     * @type {string}
     * @memberof Schedule
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'groupId'?: string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof Schedule
     */
    'createdAt': string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof Schedule
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<ScheduleCandidateDatesInner>}
     * @memberof Schedule
     */
    'candidateDates'?: Array<ScheduleCandidateDatesInner>;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof Schedule
     */
    'confirmedDateTime'?: string;
}

export const ScheduleStatusEnum = {
    Adjusting: 'adjusting',
    Confirmed: 'confirmed',
    Cancelled: 'cancelled'
} as const;

export type ScheduleStatusEnum = typeof ScheduleStatusEnum[keyof typeof ScheduleStatusEnum];

/**
 * 
 * @export
 * @interface ScheduleCandidateDatesInner
 */
export interface ScheduleCandidateDatesInner {
    /**
     * 
     * @type {string}
     * @memberof ScheduleCandidateDatesInner
     */
    'optionId': string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof ScheduleCandidateDatesInner
     */
    'datetime': string;
}
/**
 * 
 * @export
 * @interface ScheduleDetail
 */
export interface ScheduleDetail {
    /**
     * Schedule ID
     * @type {string}
     * @memberof ScheduleDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleDetail
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleDetail
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleDetail
     */
    'status': ScheduleDetailStatusEnum;
    /**
     * User ID
     * @type {string}
     * @memberof ScheduleDetail
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleDetail
     */
    'groupId'?: string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof ScheduleDetail
     */
    'createdAt': string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof ScheduleDetail
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<ScheduleCandidateDatesInner>}
     * @memberof ScheduleDetail
     */
    'candidateDates'?: Array<ScheduleCandidateDatesInner>;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof ScheduleDetail
     */
    'confirmedDateTime'?: string;
    /**
     * 
     * @type {Array<ScheduleParticipant>}
     * @memberof ScheduleDetail
     */
    'participants': Array<ScheduleParticipant>;
    /**
     * 
     * @type {Array<ScheduleVote>}
     * @memberof ScheduleDetail
     */
    'votes': Array<ScheduleVote>;
}

export const ScheduleDetailStatusEnum = {
    Adjusting: 'adjusting',
    Confirmed: 'confirmed',
    Cancelled: 'cancelled'
} as const;

export type ScheduleDetailStatusEnum = typeof ScheduleDetailStatusEnum[keyof typeof ScheduleDetailStatusEnum];

/**
 * 
 * @export
 * @interface ScheduleParticipant
 */
export interface ScheduleParticipant {
    /**
     * Participant ID (Doc ID)
     * @type {string}
     * @memberof ScheduleParticipant
     */
    'id': string;
    /**
     * Parent Schedule ID
     * @type {string}
     * @memberof ScheduleParticipant
     */
    'scheduleId': string;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleParticipant
     */
    'isGuest': boolean;
    /**
     * 
     * @type {string}
     * @memberof ScheduleParticipant
     */
    'lineUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleParticipant
     */
    'displayName': string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof ScheduleParticipant
     */
    'addedAt': string;
}
/**
 * 
 * @export
 * @interface ScheduleVote
 */
export interface ScheduleVote {
    /**
     * Vote ID (Doc ID)
     * @type {string}
     * @memberof ScheduleVote
     */
    'id': string;
    /**
     * Parent Schedule ID
     * @type {string}
     * @memberof ScheduleVote
     */
    'scheduleId': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleVote
     */
    'optionId': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleVote
     */
    'participantId': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleVote
     */
    'vote': ScheduleVoteVoteEnum;
    /**
     * 
     * @type {string}
     * @memberof ScheduleVote
     */
    'comment'?: string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof ScheduleVote
     */
    'votedAt': string;
}

export const ScheduleVoteVoteEnum = {
    Ok: 'ok',
    Maybe: 'maybe',
    Ng: 'ng'
} as const;

export type ScheduleVoteVoteEnum = typeof ScheduleVoteVoteEnum[keyof typeof ScheduleVoteVoteEnum];

/**
 * 共有メモのデータ構造
 * @export
 * @interface SharedMemo
 */
export interface SharedMemo {
    /**
     * Shared Memo ID
     * @type {string}
     * @memberof SharedMemo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SharedMemo
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SharedMemo
     */
    'templateType'?: SharedMemoTemplateTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SharedMemo
     */
    'content'?: string;
    /**
     * Creator User ID
     * @type {string}
     * @memberof SharedMemo
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof SharedMemo
     */
    'groupId'?: string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof SharedMemo
     */
    'createdAt': string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof SharedMemo
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof SharedMemo
     */
    'lastEditorId'?: string;
    /**
     * List of user IDs who can read/write this memo
     * @type {Array<string>}
     * @memberof SharedMemo
     */
    'readableUserIds': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof SharedMemo
     */
    'isArchived': boolean;
}

export const SharedMemoTemplateTypeEnum = {
    Meeting: 'meeting',
    Outing: 'outing',
    Free: 'free'
} as const;

export type SharedMemoTemplateTypeEnum = typeof SharedMemoTemplateTypeEnum[keyof typeof SharedMemoTemplateTypeEnum];

/**
 * 共有メモの編集者情報
 * @export
 * @interface SharedMemoEditor
 */
export interface SharedMemoEditor {
    /**
     * Editor\'s User ID
     * @type {string}
     * @memberof SharedMemoEditor
     */
    'userId': string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof SharedMemoEditor
     */
    'addedAt': string;
}
/**
 * 
 * @export
 * @interface UpdateSharedMemoInput
 */
export interface UpdateSharedMemoInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateSharedMemoInput
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSharedMemoInput
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface VoteInput
 */
export interface VoteInput {
    /**
     * 投票対象の候補日オプションID
     * @type {string}
     * @memberof VoteInput
     */
    'optionId': string;
    /**
     * 投票内容
     * @type {string}
     * @memberof VoteInput
     */
    'vote': VoteInputVoteEnum;
    /**
     * コメント (任意)
     * @type {string}
     * @memberof VoteInput
     */
    'comment'?: string;
}

export const VoteInputVoteEnum = {
    Ok: 'ok',
    Maybe: 'maybe',
    Ng: 'ng'
} as const;

export type VoteInputVoteEnum = typeof VoteInputVoteEnum[keyof typeof VoteInputVoteEnum];

/**
 * 
 * @export
 * @interface WarikanMember
 */
export interface WarikanMember {
    /**
     * Member ID (Doc ID)
     * @type {string}
     * @memberof WarikanMember
     */
    'id': string;
    /**
     * Parent Project ID
     * @type {string}
     * @memberof WarikanMember
     */
    'projectId': string;
    /**
     * 
     * @type {boolean}
     * @memberof WarikanMember
     */
    'isGuest': boolean;
    /**
     * 
     * @type {string}
     * @memberof WarikanMember
     */
    'lineUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WarikanMember
     */
    'displayName': string;
    /**
     * 精算時の収支
     * @type {number}
     * @memberof WarikanMember
     */
    'balance': number;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof WarikanMember
     */
    'addedAt': string;
}
/**
 * 
 * @export
 * @interface WarikanPayment
 */
export interface WarikanPayment {
    /**
     * Payment ID
     * @type {string}
     * @memberof WarikanPayment
     */
    'id': string;
    /**
     * Parent Project ID
     * @type {string}
     * @memberof WarikanPayment
     */
    'projectId': string;
    /**
     * 支払者のメンバーID
     * @type {string}
     * @memberof WarikanPayment
     */
    'payerMemberId': string;
    /**
     * 
     * @type {number}
     * @memberof WarikanPayment
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof WarikanPayment
     */
    'description'?: string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof WarikanPayment
     */
    'paymentDate'?: string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof WarikanPayment
     */
    'createdAt': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WarikanPayment
     */
    'participants'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WarikanProject
 */
export interface WarikanProject {
    /**
     * Project ID
     * @type {string}
     * @memberof WarikanProject
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WarikanProject
     */
    'projectName': string;
    /**
     * 
     * @type {string}
     * @memberof WarikanProject
     */
    'status': WarikanProjectStatusEnum;
    /**
     * User ID
     * @type {string}
     * @memberof WarikanProject
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof WarikanProject
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WarikanProject
     */
    'shareUrlToken'?: string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof WarikanProject
     */
    'createdAt': string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof WarikanProject
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof WarikanProject
     */
    'totalAmount': number;
    /**
     * 
     * @type {number}
     * @memberof WarikanProject
     */
    'memberCount': number;
}

export const WarikanProjectStatusEnum = {
    Active: 'active',
    Settled: 'settled'
} as const;

export type WarikanProjectStatusEnum = typeof WarikanProjectStatusEnum[keyof typeof WarikanProjectStatusEnum];

/**
 * 
 * @export
 * @interface WarikanProjectDetail
 */
export interface WarikanProjectDetail {
    /**
     * Project ID
     * @type {string}
     * @memberof WarikanProjectDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WarikanProjectDetail
     */
    'projectName': string;
    /**
     * 
     * @type {string}
     * @memberof WarikanProjectDetail
     */
    'status': WarikanProjectDetailStatusEnum;
    /**
     * User ID
     * @type {string}
     * @memberof WarikanProjectDetail
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof WarikanProjectDetail
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WarikanProjectDetail
     */
    'shareUrlToken'?: string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof WarikanProjectDetail
     */
    'createdAt': string;
    /**
     * ISO8601形式の日時文字列 (UTC)
     * @type {string}
     * @memberof WarikanProjectDetail
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof WarikanProjectDetail
     */
    'totalAmount': number;
    /**
     * 
     * @type {number}
     * @memberof WarikanProjectDetail
     */
    'memberCount': number;
    /**
     * 
     * @type {Array<WarikanMember>}
     * @memberof WarikanProjectDetail
     */
    'members': Array<WarikanMember>;
    /**
     * 
     * @type {Array<WarikanPayment>}
     * @memberof WarikanProjectDetail
     */
    'payments': Array<WarikanPayment>;
}

export const WarikanProjectDetailStatusEnum = {
    Active: 'active',
    Settled: 'settled'
} as const;

export type WarikanProjectDetailStatusEnum = typeof WarikanProjectDetailStatusEnum[keyof typeof WarikanProjectDetailStatusEnum];

/**
 * 
 * @export
 * @interface WarikanSettlement
 */
export interface WarikanSettlement {
    /**
     * 
     * @type {WarikanMember}
     * @memberof WarikanSettlement
     */
    'payer': WarikanMember;
    /**
     * 
     * @type {WarikanMember}
     * @memberof WarikanSettlement
     */
    'receiver': WarikanMember;
    /**
     * 
     * @type {number}
     * @memberof WarikanSettlement
     */
    'amount': number;
    /**
     * 
     * @type {boolean}
     * @memberof WarikanSettlement
     */
    'isDone'?: boolean;
}

/**
 * ScheduleApi - axios parameter creator
 * @export
 */
export const ScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 候補日時追加
         * @param {string} id Schedule ID
         * @param {AddCandidateDatesInput} addCandidateDatesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScheduleCandidateDates: async (id: string, addCandidateDatesInput: AddCandidateDatesInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addScheduleCandidateDates', 'id', id)
            // verify required parameter 'addCandidateDatesInput' is not null or undefined
            assertParamExists('addScheduleCandidateDates', 'addCandidateDatesInput', addCandidateDatesInput)
            const localVarPath = `/schedules/{id}/candidates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCandidateDatesInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary スケジュールに参加者追加
         * @param {string} id Schedule ID
         * @param {AddParticipantInput} addParticipantInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScheduleParticipant: async (id: string, addParticipantInput: AddParticipantInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addScheduleParticipant', 'id', id)
            // verify required parameter 'addParticipantInput' is not null or undefined
            assertParamExists('addScheduleParticipant', 'addParticipantInput', addParticipantInput)
            const localVarPath = `/schedules/{id}/participants`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addParticipantInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 候補日時に投票
         * @param {string} id Schedule ID
         * @param {VoteInput} voteInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScheduleVote: async (id: string, voteInput: VoteInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addScheduleVote', 'id', id)
            // verify required parameter 'voteInput' is not null or undefined
            assertParamExists('addScheduleVote', 'voteInput', voteInput)
            const localVarPath = `/schedules/{id}/votes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(voteInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary スケジュールを確定する
         * @param {string} id Schedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSchedule: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('confirmSchedule', 'id', id)
            const localVarPath = `/schedules/{id}/confirm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 新規スケジュール作成
         * @param {CreateScheduleInput} createScheduleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedule: async (createScheduleInput: CreateScheduleInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createScheduleInput' is not null or undefined
            assertParamExists('createSchedule', 'createScheduleInput', createScheduleInput)
            const localVarPath = `/schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScheduleInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary スケジュール詳細取得
         * @param {string} id Schedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getScheduleById', 'id', id)
            const localVarPath = `/schedules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleApi - functional programming interface
 * @export
 */
export const ScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 候補日時追加
         * @param {string} id Schedule ID
         * @param {AddCandidateDatesInput} addCandidateDatesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addScheduleCandidateDates(id: string, addCandidateDatesInput: AddCandidateDatesInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addScheduleCandidateDates(id, addCandidateDatesInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.addScheduleCandidateDates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary スケジュールに参加者追加
         * @param {string} id Schedule ID
         * @param {AddParticipantInput} addParticipantInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addScheduleParticipant(id: string, addParticipantInput: AddParticipantInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleParticipant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addScheduleParticipant(id, addParticipantInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.addScheduleParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 候補日時に投票
         * @param {string} id Schedule ID
         * @param {VoteInput} voteInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addScheduleVote(id: string, voteInput: VoteInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addScheduleVote(id, voteInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.addScheduleVote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary スケジュールを確定する
         * @param {string} id Schedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmSchedule(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmSchedule(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.confirmSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 新規スケジュール作成
         * @param {CreateScheduleInput} createScheduleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSchedule(createScheduleInput: CreateScheduleInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchedule(createScheduleInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.createSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary スケジュール詳細取得
         * @param {string} id Schedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduleById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduleById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.getScheduleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScheduleApi - factory interface
 * @export
 */
export const ScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduleApiFp(configuration)
    return {
        /**
         * 
         * @summary 候補日時追加
         * @param {string} id Schedule ID
         * @param {AddCandidateDatesInput} addCandidateDatesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScheduleCandidateDates(id: string, addCandidateDatesInput: AddCandidateDatesInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addScheduleCandidateDates(id, addCandidateDatesInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary スケジュールに参加者追加
         * @param {string} id Schedule ID
         * @param {AddParticipantInput} addParticipantInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScheduleParticipant(id: string, addParticipantInput: AddParticipantInput, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleParticipant> {
            return localVarFp.addScheduleParticipant(id, addParticipantInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 候補日時に投票
         * @param {string} id Schedule ID
         * @param {VoteInput} voteInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScheduleVote(id: string, voteInput: VoteInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addScheduleVote(id, voteInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary スケジュールを確定する
         * @param {string} id Schedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSchedule(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.confirmSchedule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 新規スケジュール作成
         * @param {CreateScheduleInput} createScheduleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedule(createScheduleInput: CreateScheduleInput, options?: RawAxiosRequestConfig): AxiosPromise<Schedule> {
            return localVarFp.createSchedule(createScheduleInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary スケジュール詳細取得
         * @param {string} id Schedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleDetail> {
            return localVarFp.getScheduleById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduleApi - object-oriented interface
 * @export
 * @class ScheduleApi
 * @extends {BaseAPI}
 */
export class ScheduleApi extends BaseAPI {
    /**
     * 
     * @summary 候補日時追加
     * @param {string} id Schedule ID
     * @param {AddCandidateDatesInput} addCandidateDatesInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public addScheduleCandidateDates(id: string, addCandidateDatesInput: AddCandidateDatesInput, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).addScheduleCandidateDates(id, addCandidateDatesInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary スケジュールに参加者追加
     * @param {string} id Schedule ID
     * @param {AddParticipantInput} addParticipantInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public addScheduleParticipant(id: string, addParticipantInput: AddParticipantInput, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).addScheduleParticipant(id, addParticipantInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 候補日時に投票
     * @param {string} id Schedule ID
     * @param {VoteInput} voteInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public addScheduleVote(id: string, voteInput: VoteInput, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).addScheduleVote(id, voteInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary スケジュールを確定する
     * @param {string} id Schedule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public confirmSchedule(id: string, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).confirmSchedule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 新規スケジュール作成
     * @param {CreateScheduleInput} createScheduleInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public createSchedule(createScheduleInput: CreateScheduleInput, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).createSchedule(createScheduleInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary スケジュール詳細取得
     * @param {string} id Schedule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public getScheduleById(id: string, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).getScheduleById(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SharedMemoApi - axios parameter creator
 * @export
 */
export const SharedMemoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive (soft delete) a shared memo
         * @param {string} id Shared Memo ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveSharedMemo: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('archiveSharedMemo', 'id', id)
            const localVarPath = `/shared-memos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a shared memo
         * @param {CreateSharedMemoInput} createSharedMemoInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSharedMemo: async (createSharedMemoInput: CreateSharedMemoInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSharedMemoInput' is not null or undefined
            assertParamExists('createSharedMemo', 'createSharedMemoInput', createSharedMemoInput)
            const localVarPath = `/shared-memos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSharedMemoInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a shared memo by ID
         * @param {string} id Shared Memo ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedMemoById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSharedMemoById', 'id', id)
            const localVarPath = `/shared-memos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List accessible shared memos (pagination)
         * @param {number} [limit] Max number of memos to return
         * @param {string} [cursor] Cursor for pagination (last memo ID from previous page)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedMemos: async (limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shared-memos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a shared memo
         * @param {string} id Shared Memo ID
         * @param {UpdateSharedMemoInput} updateSharedMemoInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSharedMemo: async (id: string, updateSharedMemoInput: UpdateSharedMemoInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSharedMemo', 'id', id)
            // verify required parameter 'updateSharedMemoInput' is not null or undefined
            assertParamExists('updateSharedMemo', 'updateSharedMemoInput', updateSharedMemoInput)
            const localVarPath = `/shared-memos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSharedMemoInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharedMemoApi - functional programming interface
 * @export
 */
export const SharedMemoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SharedMemoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Archive (soft delete) a shared memo
         * @param {string} id Shared Memo ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveSharedMemo(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveSharedMemo(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SharedMemoApi.archiveSharedMemo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a shared memo
         * @param {CreateSharedMemoInput} createSharedMemoInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSharedMemo(createSharedMemoInput: CreateSharedMemoInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSharedMemo(createSharedMemoInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SharedMemoApi.createSharedMemo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a shared memo by ID
         * @param {string} id Shared Memo ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedMemoById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedMemoById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SharedMemoApi.getSharedMemoById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List accessible shared memos (pagination)
         * @param {number} [limit] Max number of memos to return
         * @param {string} [cursor] Cursor for pagination (last memo ID from previous page)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSharedMemos(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSharedMemosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSharedMemos(limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SharedMemoApi.listSharedMemos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a shared memo
         * @param {string} id Shared Memo ID
         * @param {UpdateSharedMemoInput} updateSharedMemoInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSharedMemo(id: string, updateSharedMemoInput: UpdateSharedMemoInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSharedMemo(id, updateSharedMemoInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SharedMemoApi.updateSharedMemo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SharedMemoApi - factory interface
 * @export
 */
export const SharedMemoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SharedMemoApiFp(configuration)
    return {
        /**
         * 
         * @summary Archive (soft delete) a shared memo
         * @param {string} id Shared Memo ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveSharedMemo(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.archiveSharedMemo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a shared memo
         * @param {CreateSharedMemoInput} createSharedMemoInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSharedMemo(createSharedMemoInput: CreateSharedMemoInput, options?: RawAxiosRequestConfig): AxiosPromise<SharedMemo> {
            return localVarFp.createSharedMemo(createSharedMemoInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a shared memo by ID
         * @param {string} id Shared Memo ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedMemoById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SharedMemo> {
            return localVarFp.getSharedMemoById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List accessible shared memos (pagination)
         * @param {number} [limit] Max number of memos to return
         * @param {string} [cursor] Cursor for pagination (last memo ID from previous page)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedMemos(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListSharedMemosResponse> {
            return localVarFp.listSharedMemos(limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a shared memo
         * @param {string} id Shared Memo ID
         * @param {UpdateSharedMemoInput} updateSharedMemoInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSharedMemo(id: string, updateSharedMemoInput: UpdateSharedMemoInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateSharedMemo(id, updateSharedMemoInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SharedMemoApi - object-oriented interface
 * @export
 * @class SharedMemoApi
 * @extends {BaseAPI}
 */
export class SharedMemoApi extends BaseAPI {
    /**
     * 
     * @summary Archive (soft delete) a shared memo
     * @param {string} id Shared Memo ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedMemoApi
     */
    public archiveSharedMemo(id: string, options?: RawAxiosRequestConfig) {
        return SharedMemoApiFp(this.configuration).archiveSharedMemo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a shared memo
     * @param {CreateSharedMemoInput} createSharedMemoInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedMemoApi
     */
    public createSharedMemo(createSharedMemoInput: CreateSharedMemoInput, options?: RawAxiosRequestConfig) {
        return SharedMemoApiFp(this.configuration).createSharedMemo(createSharedMemoInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a shared memo by ID
     * @param {string} id Shared Memo ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedMemoApi
     */
    public getSharedMemoById(id: string, options?: RawAxiosRequestConfig) {
        return SharedMemoApiFp(this.configuration).getSharedMemoById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List accessible shared memos (pagination)
     * @param {number} [limit] Max number of memos to return
     * @param {string} [cursor] Cursor for pagination (last memo ID from previous page)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedMemoApi
     */
    public listSharedMemos(limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return SharedMemoApiFp(this.configuration).listSharedMemos(limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a shared memo
     * @param {string} id Shared Memo ID
     * @param {UpdateSharedMemoInput} updateSharedMemoInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedMemoApi
     */
    public updateSharedMemo(id: string, updateSharedMemoInput: UpdateSharedMemoInput, options?: RawAxiosRequestConfig) {
        return SharedMemoApiFp(this.configuration).updateSharedMemo(id, updateSharedMemoInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SharedMemoEditorApi - axios parameter creator
 * @export
 */
export const SharedMemoEditorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add an editor to a shared memo
         * @param {string} id Shared Memo ID
         * @param {AddEditorInput} addEditorInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSharedMemoEditor: async (id: string, addEditorInput: AddEditorInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addSharedMemoEditor', 'id', id)
            // verify required parameter 'addEditorInput' is not null or undefined
            assertParamExists('addSharedMemoEditor', 'addEditorInput', addEditorInput)
            const localVarPath = `/shared-memos/{id}/editors`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addEditorInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an editor from a shared memo
         * @param {string} id Shared Memo ID
         * @param {string} editorId Editor User ID to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedMemoEditor: async (id: string, editorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeSharedMemoEditor', 'id', id)
            // verify required parameter 'editorId' is not null or undefined
            assertParamExists('removeSharedMemoEditor', 'editorId', editorId)
            const localVarPath = `/shared-memos/{id}/editors/{editorId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"editorId"}}`, encodeURIComponent(String(editorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharedMemoEditorApi - functional programming interface
 * @export
 */
export const SharedMemoEditorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SharedMemoEditorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add an editor to a shared memo
         * @param {string} id Shared Memo ID
         * @param {AddEditorInput} addEditorInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSharedMemoEditor(id: string, addEditorInput: AddEditorInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSharedMemoEditor(id, addEditorInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SharedMemoEditorApi.addSharedMemoEditor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove an editor from a shared memo
         * @param {string} id Shared Memo ID
         * @param {string} editorId Editor User ID to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSharedMemoEditor(id: string, editorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSharedMemoEditor(id, editorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SharedMemoEditorApi.removeSharedMemoEditor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SharedMemoEditorApi - factory interface
 * @export
 */
export const SharedMemoEditorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SharedMemoEditorApiFp(configuration)
    return {
        /**
         * 
         * @summary Add an editor to a shared memo
         * @param {string} id Shared Memo ID
         * @param {AddEditorInput} addEditorInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSharedMemoEditor(id: string, addEditorInput: AddEditorInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addSharedMemoEditor(id, addEditorInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an editor from a shared memo
         * @param {string} id Shared Memo ID
         * @param {string} editorId Editor User ID to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedMemoEditor(id: string, editorId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeSharedMemoEditor(id, editorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SharedMemoEditorApi - object-oriented interface
 * @export
 * @class SharedMemoEditorApi
 * @extends {BaseAPI}
 */
export class SharedMemoEditorApi extends BaseAPI {
    /**
     * 
     * @summary Add an editor to a shared memo
     * @param {string} id Shared Memo ID
     * @param {AddEditorInput} addEditorInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedMemoEditorApi
     */
    public addSharedMemoEditor(id: string, addEditorInput: AddEditorInput, options?: RawAxiosRequestConfig) {
        return SharedMemoEditorApiFp(this.configuration).addSharedMemoEditor(id, addEditorInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an editor from a shared memo
     * @param {string} id Shared Memo ID
     * @param {string} editorId Editor User ID to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedMemoEditorApi
     */
    public removeSharedMemoEditor(id: string, editorId: string, options?: RawAxiosRequestConfig) {
        return SharedMemoEditorApiFp(this.configuration).removeSharedMemoEditor(id, editorId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WarikanApi - axios parameter creator
 * @export
 */
export const WarikanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 割り勘プロジェクトにメンバー追加
         * @param {string} id Project ID
         * @param {AddMemberInput} addMemberInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWarikanMember: async (id: string, addMemberInput: AddMemberInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addWarikanMember', 'id', id)
            // verify required parameter 'addMemberInput' is not null or undefined
            assertParamExists('addWarikanMember', 'addMemberInput', addMemberInput)
            const localVarPath = `/warikan/projects/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMemberInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 支払い記録追加
         * @param {string} id Project ID
         * @param {AddPaymentInput} addPaymentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWarikanPayment: async (id: string, addPaymentInput: AddPaymentInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addWarikanPayment', 'id', id)
            // verify required parameter 'addPaymentInput' is not null or undefined
            assertParamExists('addWarikanPayment', 'addPaymentInput', addPaymentInput)
            const localVarPath = `/warikan/projects/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPaymentInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 新規割り勘プロジェクト作成
         * @param {CreateProjectInput} createProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWarikanProject: async (createProjectInput: CreateProjectInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectInput' is not null or undefined
            assertParamExists('createWarikanProject', 'createProjectInput', createProjectInput)
            const localVarPath = `/warikan/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 割り勘プロジェクト詳細取得
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarikanProjectById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWarikanProjectById', 'id', id)
            const localVarPath = `/warikan/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 精算結果取得
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarikanSettlements: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWarikanSettlements', 'id', id)
            const localVarPath = `/warikan/projects/{id}/settlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 支払い記録一覧取得
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWarikanPayments: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listWarikanPayments', 'id', id)
            const localVarPath = `/warikan/projects/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary プロジェクトを精算済みにする
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settleWarikanProject: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('settleWarikanProject', 'id', id)
            const localVarPath = `/warikan/projects/{id}/settle`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WarikanApi - functional programming interface
 * @export
 */
export const WarikanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WarikanApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 割り勘プロジェクトにメンバー追加
         * @param {string} id Project ID
         * @param {AddMemberInput} addMemberInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWarikanMember(id: string, addMemberInput: AddMemberInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarikanMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWarikanMember(id, addMemberInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarikanApi.addWarikanMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 支払い記録追加
         * @param {string} id Project ID
         * @param {AddPaymentInput} addPaymentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWarikanPayment(id: string, addPaymentInput: AddPaymentInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddWarikanPayment201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWarikanPayment(id, addPaymentInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarikanApi.addWarikanPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 新規割り勘プロジェクト作成
         * @param {CreateProjectInput} createProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWarikanProject(createProjectInput: CreateProjectInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarikanProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWarikanProject(createProjectInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarikanApi.createWarikanProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 割り勘プロジェクト詳細取得
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWarikanProjectById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarikanProjectDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWarikanProjectById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarikanApi.getWarikanProjectById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 精算結果取得
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWarikanSettlements(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WarikanSettlement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWarikanSettlements(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarikanApi.getWarikanSettlements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 支払い記録一覧取得
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWarikanPayments(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WarikanPayment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWarikanPayments(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarikanApi.listWarikanPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary プロジェクトを精算済みにする
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settleWarikanProject(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarikanProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settleWarikanProject(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarikanApi.settleWarikanProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WarikanApi - factory interface
 * @export
 */
export const WarikanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WarikanApiFp(configuration)
    return {
        /**
         * 
         * @summary 割り勘プロジェクトにメンバー追加
         * @param {string} id Project ID
         * @param {AddMemberInput} addMemberInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWarikanMember(id: string, addMemberInput: AddMemberInput, options?: RawAxiosRequestConfig): AxiosPromise<WarikanMember> {
            return localVarFp.addWarikanMember(id, addMemberInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 支払い記録追加
         * @param {string} id Project ID
         * @param {AddPaymentInput} addPaymentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWarikanPayment(id: string, addPaymentInput: AddPaymentInput, options?: RawAxiosRequestConfig): AxiosPromise<AddWarikanPayment201Response> {
            return localVarFp.addWarikanPayment(id, addPaymentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 新規割り勘プロジェクト作成
         * @param {CreateProjectInput} createProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWarikanProject(createProjectInput: CreateProjectInput, options?: RawAxiosRequestConfig): AxiosPromise<WarikanProject> {
            return localVarFp.createWarikanProject(createProjectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 割り勘プロジェクト詳細取得
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarikanProjectById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<WarikanProjectDetail> {
            return localVarFp.getWarikanProjectById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 精算結果取得
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarikanSettlements(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<WarikanSettlement>> {
            return localVarFp.getWarikanSettlements(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 支払い記録一覧取得
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWarikanPayments(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<WarikanPayment>> {
            return localVarFp.listWarikanPayments(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary プロジェクトを精算済みにする
         * @param {string} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settleWarikanProject(id: string, options?: RawAxiosRequestConfig): AxiosPromise<WarikanProject> {
            return localVarFp.settleWarikanProject(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WarikanApi - object-oriented interface
 * @export
 * @class WarikanApi
 * @extends {BaseAPI}
 */
export class WarikanApi extends BaseAPI {
    /**
     * 
     * @summary 割り勘プロジェクトにメンバー追加
     * @param {string} id Project ID
     * @param {AddMemberInput} addMemberInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarikanApi
     */
    public addWarikanMember(id: string, addMemberInput: AddMemberInput, options?: RawAxiosRequestConfig) {
        return WarikanApiFp(this.configuration).addWarikanMember(id, addMemberInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 支払い記録追加
     * @param {string} id Project ID
     * @param {AddPaymentInput} addPaymentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarikanApi
     */
    public addWarikanPayment(id: string, addPaymentInput: AddPaymentInput, options?: RawAxiosRequestConfig) {
        return WarikanApiFp(this.configuration).addWarikanPayment(id, addPaymentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 新規割り勘プロジェクト作成
     * @param {CreateProjectInput} createProjectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarikanApi
     */
    public createWarikanProject(createProjectInput: CreateProjectInput, options?: RawAxiosRequestConfig) {
        return WarikanApiFp(this.configuration).createWarikanProject(createProjectInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 割り勘プロジェクト詳細取得
     * @param {string} id Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarikanApi
     */
    public getWarikanProjectById(id: string, options?: RawAxiosRequestConfig) {
        return WarikanApiFp(this.configuration).getWarikanProjectById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 精算結果取得
     * @param {string} id Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarikanApi
     */
    public getWarikanSettlements(id: string, options?: RawAxiosRequestConfig) {
        return WarikanApiFp(this.configuration).getWarikanSettlements(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 支払い記録一覧取得
     * @param {string} id Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarikanApi
     */
    public listWarikanPayments(id: string, options?: RawAxiosRequestConfig) {
        return WarikanApiFp(this.configuration).listWarikanPayments(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary プロジェクトを精算済みにする
     * @param {string} id Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarikanApi
     */
    public settleWarikanProject(id: string, options?: RawAxiosRequestConfig) {
        return WarikanApiFp(this.configuration).settleWarikanProject(id, options).then((request) => request(this.axios, this.basePath));
    }
}



